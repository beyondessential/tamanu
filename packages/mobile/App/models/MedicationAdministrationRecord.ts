import { Entity, Column, ManyToOne, JoinColumn } from 'typeorm';
import { BaseModel } from './BaseModel';
import { Prescription } from './Prescription';
import { ReferenceData } from './ReferenceData';
import { User } from './User';
import { DateTimeStringColumn } from './DateColumns';
import { SYNC_DIRECTIONS } from './types';
import {
  addDays,
  addHours,
  addMonths,
  endOfDay,
  getDate,
  isValid,
  setDate,
  startOfDay,
} from 'date-fns';
import { areDatesInSameTimeSlot, getFirstAdministrationDate } from '~/ui/helpers/medicationHelpers';
import { ADMINISTRATION_FREQUENCIES } from '~/constants/medications';

@Entity('medication_administration_records')
export class MedicationAdministrationRecord extends BaseModel {
  static syncDirection = SYNC_DIRECTIONS.BIDIRECTIONAL;

  @Column({ type: 'varchar', nullable: true })
  status: string;

  @DateTimeStringColumn({ nullable: false })
  dueAt: string;

  @DateTimeStringColumn({ nullable: true })
  recordedAt: string;

  @Column({ type: 'boolean', nullable: false, default: false })
  isAutoGenerated: boolean;

  @Column({ type: 'text', nullable: true })
  changingStatusReason: string;

  @Column({ type: 'text', nullable: true })
  changingNotGivenInfoReason: string;

  @Column({ type: 'boolean', nullable: false, default: false })
  isEdited: boolean;

  @Column({ type: 'boolean', nullable: true })
  isError: boolean;

  @Column({ type: 'text', nullable: true })
  errorNotes: string;

  // Relations
  @Column({ type: 'varchar', nullable: true })
  prescriptionId: string;
  @ManyToOne(() => Prescription, { nullable: true })
  @JoinColumn({ name: 'prescriptionId' })
  prescription: Prescription;

  @Column({ type: 'varchar', nullable: true })
  reasonNotGivenId: string;
  @ManyToOne(() => ReferenceData, { nullable: true })
  @JoinColumn({ name: 'reasonNotGivenId' })
  reasonNotGiven: ReferenceData;

  @Column({ type: 'varchar', nullable: true })
  recordedByUserId: string;
  @ManyToOne(() => User, { nullable: true })
  @JoinColumn({ name: 'recordedByUserId' })
  recordedByUser: User;

  static async generateMedicationAdministrationRecords(prescription: Prescription) {
    if (
      !prescription.frequency ||
      !prescription.startDate ||
      prescription.frequency === ADMINISTRATION_FREQUENCIES.AS_DIRECTED
    ) {
      return;
    }

    // We don't need to get the last MAR of the prescription as we only generate the MARs on mobile for the first time it has been created

    // If the prescription is immediately, create a MAR for the start date
    if (prescription.frequency === ADMINISTRATION_FREQUENCIES.IMMEDIATELY) {
      await this.createAndSaveOne({
        prescriptionId: prescription.id,
        dueAt: prescription.startDate,
        isAutoGenerated: true,
      });
      return;
    }

    // Get the first administration date for the prescription
    let firstAdministrationDate: Date | undefined;
    const idealTimes = prescription.idealTimes?.split(',') || [];
    if (idealTimes && idealTimes.length > 0) {
      firstAdministrationDate = getFirstAdministrationDate(
        new Date(prescription.startDate),
        idealTimes,
      );
    }

    const upcomingRecordsShouldBeGeneratedTimeFrame = 72;

    let endDate = endOfDay(addHours(new Date(), upcomingRecordsShouldBeGeneratedTimeFrame));

    // Override with prescription end date if it's earlier
    if (prescription.endDate && new Date(prescription.endDate) < endDate) {
      endDate = new Date(prescription.endDate);
    }

    // Get the last due date for the prescription
    let lastDueDate: Date;
    if (firstAdministrationDate) {
      lastDueDate = firstAdministrationDate;
    } else {
      lastDueDate = new Date(prescription.startDate);
    }

    // Generate the upcoming MARs
    while (lastDueDate < endDate) {
      for (const idealTime of idealTimes || []) {
        const [hours, minutes] = idealTime.split(':').map(Number);
        const nextDueDate = new Date(
          lastDueDate.getFullYear(),
          lastDueDate.getMonth(),
          lastDueDate.getDate(),
          hours,
          minutes,
          0,
        );

        const prescriptionStartDate = new Date(prescription.startDate);
        // Skip if the next due date is before the start date and not in the same time slot, after the end date, or after the prescription was discontinued
        // For cron job, skip if the next due date is before the last due date (to avoid creating duplicate records)
        if (
          (nextDueDate < prescriptionStartDate &&
            !areDatesInSameTimeSlot(prescriptionStartDate, nextDueDate)) ||
          nextDueDate > endDate ||
          (prescription.discontinuedDate && nextDueDate >= new Date(prescription.discontinuedDate))
        ) {
          continue;
        }

        // Skip if administration date is not valid (required to pass unit tests)
        if (isValid(nextDueDate)) {
          await this.createAndSaveOne({
            prescriptionId: prescription.id,
            dueAt: nextDueDate.toISOString(),
            isAutoGenerated: true,
          });
        }
      }
      // Get next administration date based on frequency
      switch (prescription.frequency) {
        case ADMINISTRATION_FREQUENCIES.EVERY_SECOND_DAY:
          lastDueDate = startOfDay(addDays(lastDueDate, 2));
          break;
        case ADMINISTRATION_FREQUENCIES.ONCE_A_WEEK:
          lastDueDate = startOfDay(addDays(lastDueDate, 7));
          break;
        case ADMINISTRATION_FREQUENCIES.ONCE_A_MONTH: {
          const lastDueDay = getDate(lastDueDate);
          // If the due date of the first administration is the 29th or 30th or 31st, then set the next due date to the 1st of the second next month
          if (lastDueDay >= 29) {
            lastDueDate = startOfDay(setDate(addMonths(lastDueDate, 2), 1));
          } else {
            lastDueDate = startOfDay(setDate(addMonths(lastDueDate, 1), lastDueDay));
          }
          break;
        }
        default:
          lastDueDate = startOfDay(addDays(lastDueDate, 1));
          break;
      }
    }
  }
}
