import { Entity, Column, ManyToOne, JoinColumn } from 'typeorm';
import { BaseModel } from './BaseModel';
import { Prescription } from './Prescription';
import { ReferenceData } from './ReferenceData';
import { User } from './User';
import { DateTimeStringColumn } from './DateColumns';
import { SYNC_DIRECTIONS } from './types';
import {
  addDays,
  addHours,
  addMonths,
  endOfDay,
  getDate,
  isValid,
  setDate,
  startOfDay,
} from 'date-fns';
import {
  areDatesInSameTimeSlot,
  getFirstAdministrationDate,
} from '~/ui/helpers/medicationHelpers';
import { ADMINISTRATION_FREQUENCIES } from '~/constants/medications';
import { EncounterPrescription } from './EncounterPrescription';
import { EncounterType } from '~/types/IEncounter';
import { Task } from './Task';
import { TASK_STATUSES, TASK_TYPES } from '~/constants/tasks';
import { getCurrentDateTimeString, toDateTimeString } from '~/ui/helpers/date';
import { SYSTEM_USER_UUID } from '~/constants';

@Entity('medication_administration_records')
export class MedicationAdministrationRecord extends BaseModel {
  static syncDirection = SYNC_DIRECTIONS.BIDIRECTIONAL;

  @Column({ type: 'varchar', nullable: true })
  status: string;

  @DateTimeStringColumn({ nullable: false })
  dueAt: string;

  @DateTimeStringColumn({ nullable: true })
  recordedAt: string;

  @Column({ type: 'boolean', nullable: false, default: false })
  isAutoGenerated: boolean;

  @Column({ type: 'text', nullable: true })
  changingStatusReason: string;

  @Column({ type: 'text', nullable: true })
  changingNotGivenInfoReason: string;

  @Column({ type: 'boolean', nullable: false, default: false })
  isEdited: boolean;

  @Column({ type: 'boolean', nullable: true })
  isError: boolean;

  @Column({ type: 'text', nullable: true })
  errorNotes: string;

  // Relations
  @Column({ type: 'varchar', nullable: true })
  prescriptionId: string;
  @ManyToOne(() => Prescription, { nullable: true })
  @JoinColumn({ name: 'prescriptionId' })
  prescription: Prescription;

  @Column({ type: 'varchar', nullable: true })
  reasonNotGivenId: string;
  @ManyToOne(() => ReferenceData, { nullable: true })
  @JoinColumn({ name: 'reasonNotGivenId' })
  reasonNotGiven: ReferenceData;

  @Column({ type: 'varchar', nullable: true })
  recordedByUserId: string;
  @ManyToOne(() => User, { nullable: true })
  @JoinColumn({ name: 'recordedByUserId' })
  recordedByUser: User;

  static async generateMedicationAdministrationRecords(prescription: Prescription) {
    if (
      !prescription.frequency ||
      !prescription.startDate ||
      prescription.frequency === ADMINISTRATION_FREQUENCIES.AS_DIRECTED
    ) {
      return;
    }

    // We don't need to get the last MAR of the prescription as we only generate the MARs on mobile for the first time it has been created

    // If the prescription is immediately, create a MAR for the start date
    if (prescription.frequency === ADMINISTRATION_FREQUENCIES.IMMEDIATELY) {
      const mar = await this.createAndSaveOne({
        prescriptionId: prescription.id,
        dueAt: prescription.startDate,
        isAutoGenerated: true,
      });
      await MedicationAdministrationRecord.createMedicationDueTaskForMar(
        mar as MedicationAdministrationRecord,
      );
      return;
    }

    // Get the first administration date for the prescription
    let firstAdministrationDate: Date | undefined;
    const idealTimes = prescription.idealTimes?.split(',') || [];
    if (idealTimes && idealTimes.length > 0) {
      firstAdministrationDate = getFirstAdministrationDate(
        new Date(prescription.startDate),
        idealTimes,
      );
    }

    const upcomingRecordsShouldBeGeneratedTimeFrame = 72;

    let endDate = endOfDay(addHours(new Date(), upcomingRecordsShouldBeGeneratedTimeFrame));

    // Override with prescription end date if it's earlier
    if (prescription.endDate && new Date(prescription.endDate) < endDate) {
      endDate = new Date(prescription.endDate);
    }

    // Get the last due date for the prescription
    let lastDueDate: Date;
    if (firstAdministrationDate) {
      lastDueDate = firstAdministrationDate;
    } else {
      lastDueDate = new Date(prescription.startDate);
    }

    // Generate the upcoming MARs
    while (lastDueDate < endDate) {
      for (const idealTime of idealTimes || []) {
        const [hours, minutes] = idealTime.split(':').map(Number);
        const nextDueDate = new Date(
          lastDueDate.getFullYear(),
          lastDueDate.getMonth(),
          lastDueDate.getDate(),
          hours,
          minutes,
          0,
        );

        const prescriptionStartDate = new Date(prescription.startDate);
        // Skip if the next due date is before the start date and not in the same time slot, after the end date, or after the prescription was discontinued
        // For cron job, skip if the next due date is before the last due date (to avoid creating duplicate records)
        if (
          (nextDueDate < prescriptionStartDate &&
            !areDatesInSameTimeSlot(prescriptionStartDate, nextDueDate)) ||
          nextDueDate > endDate ||
          (prescription.discontinuedDate && nextDueDate >= new Date(prescription.discontinuedDate))
        ) {
          continue;
        }

        // Skip if administration date is not valid (required to pass unit tests)
        if (isValid(nextDueDate)) {
          const mar = await this.createAndSaveOne({
            prescriptionId: prescription.id,
            dueAt: nextDueDate.toISOString(),
            isAutoGenerated: true,
          });
          await MedicationAdministrationRecord.createMedicationDueTaskForMar(
            mar as MedicationAdministrationRecord,
          );
        }
      }
      // Get next administration date based on frequency
      switch (prescription.frequency) {
        case ADMINISTRATION_FREQUENCIES.EVERY_SECOND_DAY:
          lastDueDate = startOfDay(addDays(lastDueDate, 2));
          break;
        case ADMINISTRATION_FREQUENCIES.ONCE_A_WEEK:
          lastDueDate = startOfDay(addDays(lastDueDate, 7));
          break;
        case ADMINISTRATION_FREQUENCIES.ONCE_A_MONTH: {
          const lastDueDay = getDate(lastDueDate);
          // If the due date of the first administration is the 29th or 30th or 31st, then set the next due date to the 1st of the second next month
          if (lastDueDay >= 29) {
            lastDueDate = startOfDay(setDate(addMonths(lastDueDate, 2), 1));
          } else {
            lastDueDate = startOfDay(setDate(addMonths(lastDueDate, 1), lastDueDay));
          }
          break;
        }
        default:
          lastDueDate = startOfDay(addDays(lastDueDate, 1));
          break;
      }
    }
  }

  static async createMedicationDueTaskForMar(mar: MedicationAdministrationRecord) {
    const prescription = await Prescription.findOne({
      where: { id: mar.prescriptionId },
    });

    // Skip if this is a PRN medication
    if (!prescription || prescription.isPrn) return;

    const encounterPrescription = await EncounterPrescription.findOne({
      where: { prescription: { id: prescription.id } },
      relations: ['encounter'],
    });
    const encounter = encounterPrescription?.encounter;

    // Skip if this is not an inpatient encounter or is discharged
    if (!encounter || encounter.encounterType !== EncounterType.Admission || encounter.endDate)
      return;


    const existingTask = await Task.createQueryBuilder('task')
      .where('task.encounterId = :encounterId', { encounterId: encounter.id })
      .andWhere('task.dueTime = :dueTime', { dueTime: mar.dueAt })  
      .andWhere('task.status = :status', { status: TASK_STATUSES.TODO })
      .andWhere('task.taskType = :taskType', { taskType: TASK_TYPES.MEDICATION_DUE_TASK })
      .andWhere('task.deletedAt IS NULL')
      .select(['task.id'])
      .getOne();

    // Skip if the task at the same ideal time already exists
    if (existingTask) return;

    await Task.createAndSaveOne({
      taskType: TASK_TYPES.MEDICATION_DUE_TASK,
      encounter: encounter.id,
      name: 'Medication Due',
      dueTime: mar.dueAt,
      status: TASK_STATUSES.TODO,
      requestTime: getCurrentDateTimeString(),
      requestedByUser: SYSTEM_USER_UUID,
    });
  }
}
