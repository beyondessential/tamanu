(function() {
  var aliases, category, conversions, ex, exceptions, from, internals, key, moment, name, object, omit, pick, ref, ref1, snakeCase, to, transformers, validator, value,
    slice = [].slice;

  ref = require('lodash'), omit = ref.omit, pick = ref.pick, snakeCase = ref.snakeCase;

  object = function(pairs) {
    var i, it, len, pair;
    it = {};
    for (i = 0, len = pairs.length; i < len; i++) {
      pair = pairs[i];
      it[pair[0]] = pair[1];
    }
    return it;
  };

  internals = ['init', 'extend', 'version'];

  validator = object((function() {
    var ref1, results;
    ref1 = omit.apply(null, [require('validator')].concat(slice.call(internals)));
    results = [];
    for (key in ref1) {
      value = ref1[key];
      results.push([snakeCase(key).replace(/^is_/, ''), value]);
    }
    return results;
  })());

  exceptions = {
    '8601': 'iso_8601'
  };

  for (from in exceptions) {
    to = exceptions[from];
    if (validator[from] != null) {
      validator[to] = validator[from];
      delete validator[from];
    }
  }

  transformers = ['escape', 'trim', 'ltrim', 'rtrim', 'strip_low', 'blacklist', 'whitelist', 'normalize_email'];

  conversions = ['to_string', 'to_date', 'to_float', 'to_int', 'to_boolean'];

  validator = {
    transformers: pick.apply(null, [validator].concat(slice.call(transformers))),
    validators: omit.apply(null, [validator].concat(slice.call(transformers), slice.call(conversions))),
    conversions: object((function() {
      var ref1, results;
      ref1 = pick.apply(null, [validator].concat(slice.call(conversions)));
      results = [];
      for (key in ref1) {
        value = ref1[key];
        results.push([key.replace(/^to_/, ''), value]);
      }
      return results;
    })())
  };

  aliases = {
    validators: {
      equals: 'equal',
      float: 'decimal',
      "in": 'any',
      int: 'integer',
      length: 'len',
      matches: 'match',
      hexadecimal: 'hex',
      base_64: 'base64',
      base64: 'b64',
      iso_8601: 'iso_date'
    },
    conversions: {
      int: 'integer',
      boolean: 'bool'
    }
  };

  for (name in validator) {
    category = validator[name];
    ref1 = aliases[name];
    for (to in ref1) {
      from = ref1[to];
      if (category[to] != null) {
        category[from] = category[to];
      }
    }
  }

  validator.transformers.lower = function(value) {
    return value.toLowerCase();
  };

  validator.transformers.upper = function(value) {
    return value.toUpperCase();
  };

  validator.validators.fail = function() {
    return false;
  };

  validator.validators["true"] = function(value, strict) {
    if (strict == null) {
      strict = false;
    }
    if (strict) {
      return value === 1 || value === true || value === 'true' || value === 'yes' || value === 'on';
    } else {
      return !!value;
    }
  };

  validator.validators.none = function() {
    var args, ref2;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return !(ref2 = validator.validators)["in"].apply(ref2, args);
  };

  try {
    moment = require('moment-timezone');
    validator.validators.timezone = function(value) {
      return moment.tz.zone(value + '') != null;
    };
    validator.transformers.normalize_timezone = function(value) {
      var ref2;
      return (ref2 = moment.tz.zone(value + '')) != null ? ref2.name : void 0;
    };
  } catch (_error) {
    ex = _error;
    console.warn("The optional dependency 'moment-timezone' was not found. The related validators and transformers will not be available.");
  }

  validator.conversions.array = function(value) {
    if (value != null) {
      return [].concat(value);
    } else {
      return [];
    }
  };

  validator.conversions.identity = function(value) {
    return value;
  };

  module.exports = validator;

}).call(this);
