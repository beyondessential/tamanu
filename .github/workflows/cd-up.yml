name: CD Up

on:
  workflow_call:
    inputs:
      deploy-name:
        type: string
        required: true
      options:
        type: string
        required: true
      image-tag:
        type: string
        required: true
      control:
        type: string
        required: true
      ref:
        type: string
        required: true
    secrets:
      PULUMI_ACCESS_TOKEN:
        required: true
      TAMANU_OPS_SSH:
        required: true

permissions:
  contents: read
  pull-requests: write
  id-token: write # for Tailscale OIDC authentication

jobs:
  deploy:
    runs-on: ubuntu-latest
    name: ${{ inputs.deploy-name }}
    steps:
      - uses: actions/checkout@v6
      - id: setup
        uses: ./.github/actions/setup-cd
        with:
          ops-ssh-key: ${{ secrets.TAMANU_OPS_SSH }}
          ops-ref: ${{ fromJson(inputs.options).opsref }}
          tailscale-oauth-client-id: ${{ vars.TS_OAUTH_CLIENT_ID }}
          tailscale-tags: ${{ vars.TS_TAGS }}
          tailscale-k8s-operator-hostname: ${{ vars.TS_K8S_OPERATOR_HOSTNAME }}

      - name: Create or check namespace
        run: |
          NS_NAME="tamanu-${{ inputs.deploy-name }}"

          # Check if subnamespace anchor exists
          if kubectl -n tamanu-super get subnamespaceanchor "$NS_NAME" 2>/dev/null; then
            echo "Namespace exists, checking it's matched to this branch"
            kubectl -n "$NS_NAME" \
              get configmap auto-deploy -o json \
              | tee -a /dev/stderr \
              | jq -e '.data | [.repo == "${{ github.repository }}", .ref == "${{ inputs.ref }}"] | all'
          else
            # Create SubnamespaceAnchor - HNC will create the namespace
            kubectl apply -f - <<EOF
          apiVersion: hnc.x-k8s.io/v1alpha2
          kind: SubnamespaceAnchor
          metadata:
            name: $NS_NAME
            namespace: tamanu-super
          EOF

            # Wait for namespace to be created by HNC
            kubectl wait --for=condition=Ready subnamespaceanchor/"$NS_NAME" \
              -n tamanu-super --timeout=30s || true

            # Create tracking configmap
            kubectl -n "$NS_NAME" \
              create configmap auto-deploy \
              --from-literal=repo=${{ github.repository }} \
              --from-literal=ref=${{ inputs.ref }}
          fi

          kubectl -n "$NS_NAME" \
            patch configmap auto-deploy \
            -p '{"data":{"control":"${{ inputs.control }}"}}'

          kubectl -n "$NS_NAME" \
            patch configmap auto-deploy \
            -p '{"data":{"imageTag":"${{ inputs.image-tag }}"}}'

      - name: Generate pulumi config
        id: config
        uses: actions/github-script@v7
        env:
          K8S_CORE: ${{ vars.K8S_CORE }}
        with:
          script: |
            const cwd = '${{ github.workspace }}';
            const { configMap } = await import(`${cwd}/packages/scripts/src/ghaCdHelpers.mjs`);
            core.setOutput('pulumi', configMap('${{ inputs.deploy-name }}', '${{ inputs.image-tag }}', ${{ inputs.options }}));

      - name: Get full stack name
        id: stack
        working-directory: ops/pulumi/stacks/${{ fromJson(inputs.options).opsstack }}
        run: |
          project=$(ruby -e 'require "yaml"; puts YAML.load(open "Pulumi.yaml")["name"]')
          echo "stackname=bes/$project/${{ inputs.deploy-name }}" >> $GITHUB_OUTPUT

      - name: Up!
        uses: pulumi/actions@v5
        with:
          work-dir: ops/pulumi/stacks/${{ fromJson(inputs.options).opsstack }}
          command: up
          stack-name: ${{ steps.stack.outputs.stackname }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          comment-on-pr: true
          upsert: true
          config-map: ${{ steps.config.outputs.pulumi }}
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
